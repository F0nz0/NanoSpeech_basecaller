# import needed modules
import os, sys
from misc import inosine_detector, aggregate_genome_space, index_fasta_newlines, index_fastq_newlines_quals
from __init__ import __version__
import argparse
from datetime import datetime


# main function
def inosine_detector_main(bam_filepath, fastx_filepath, min_qual=None):
    '''
    Function to extract inosines positions on both read and genome-space dimensions.
    It is possible to use a minimum quality score for the called inosines when aggregating onto the
    genome-space the predictions.
    It takes in input the Bam, the fastx (fasta or fastq file generated by the basecaller) 
    and the threshold for the phred quality score of inosines (not required). 
    If the input fastx file is not indexed it will be indexed with custom ad-hoc functions.
    '''

    # detect fastx extention
    extention = os.path.splitext(fastx_filepath)[1][1:].lower()
    if not extention in ["fasta", "fastq"]:
        sys.exit(f"[{datetime.now()}] Input fastx extention not allowed ({extention}). It should be either fasta or fastq. Exiting...")
    print(f"[{datetime.now()}] Input fastx format detected: {extention}.", flush=True)
    if extention == "fasta":
        # asses if faih index file already exists
        fastx_index_filepath = fastx_filepath+".faih"
        if not os.path.exists(fastx_index_filepath):
            print(f"[{datetime.now()}] Producing new-lines index file for input fasta file.", flush=True)
            index_fasta_newlines(fastx_filepath)
    elif extention == "fastq":
        fastx_index_filepath = fastx_filepath+".fqih"
        if not os.path.exists(fastx_index_filepath):
            print(f"[{datetime.now()}] Producing new-lines index file for input fastq file.", flush=True)
            index_fastq_newlines_quals(fastx_filepath)

    # detect inosine to per read level
    print(f"[{datetime.now()}] Detecting inosines at per-read level.", flush=True)
    inosine_detector(bam_filepath=bam_filepath, 
                     fastx_filepath=fastx_filepath)
    
    # infer expected per_read_preds_filepath bed/tsv filepath
    per_read_preds_filepath = bam_filepath + ".per_read.bed"
    print(f"[{datetime.now()}] Per-read prediction saved to file: {per_read_preds_filepath}", flush=True)

    print(f"[{datetime.now()}] Aggregating to genome space inosine predictions.")
    # aggregate onto genome-space using the required quality threshold (if provided)
    aggregate_genome_space(per_read_preds_filepath=per_read_preds_filepath, 
                           bam_filepath=bam_filepath, 
                           save_to_tsv=True, 
                           min_qual=min_qual)
    print(f"[{datetime.now()}] Genome-space aggregated tsv file saved to: {bam_filepath}.genome_space.tsv")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description=f"""NanoSpeech inosine_detector.py v. {__version__}\nFunction to extract inosines positions on both read and genome-space dimensions.
    It is possible to use a minimum quality score for the called inosines when aggregating onto the
    genome-space the predictions.
    It takes in input the Bam, the fastx (fasta or fastq file generated by the basecaller) 
    and the threshold for the phred quality score of inosines (not required). 
    If the input fastx file is not indexed it will be indexed with custom ad-hoc functions.""")
    parser.add_argument("-b",
                        "--bam_filepath",
                        required=True,
                        type=str,
                        help="--bam_filepath: \t a <str> with the fullpath for the input BAM file.")
    parser.add_argument("-f",
                        "--fastx_filepath",
                        required=True,
                        type=str,
                        help="--fastx_filepath: \t a <str> with the fullpath for the input fasta/fastq file generated during the basecalling.")
    parser.add_argument("-q",
                        "--min_qual",
                        required=False,
                        default=None,
                        type=int,
                        help="--min_qual: \t a <int> used as minimum quality to filter inosine basecalled bases during genome space aggregation step. [None]")

    args = parser.parse_args()
    bam_filepath = args.bam_filepath
    fastx_filepath = args.fastx_filepath
    min_qual = args.min_qual
    
    # print some starting info related to version, used program and to the input arguments
    print(f"[{datetime.now()}] NanoSpeech_basecaller version: {__version__}", flush=True)
    print(f"[{datetime.now()}] inosine_detector.py Input arguments:", flush=True)
    for argument in args.__dict__.keys():
        print(f"\t- {argument} --> {args.__dict__[argument]}", flush=True)

    # launch main function
    inosine_detector_main(bam_filepath=bam_filepath,
                          fastx_filepath=fastx_filepath,
                          min_qual=min_qual)